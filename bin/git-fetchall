#!/usr/bin/env sh
# Run `git fetch` on all repos under the current dir in parallel
#
# Usage:
#
#     git fetchall
#
# With ssh pipelining:
#
#     git fetchall "git@github.com"

NAME=$(basename "$0")
TEMP="${TMPDIR-/tmp}/${NAME}.${$}.$(awk \
    'BEGIN {srand(); printf "%d\n", rand() * 10^10}')"
REPO_CACHE="${TEMP}/fetchall.txt"

ControlPath='~/.ssh/master-%r@%h:%p'

trap '
    excode=$?; trap - EXIT;
    rm -f '"$REPO_CACHE"'
    exit $excode
' INT TERM EXIT

_wait_for_ssh () {
    # Block until a multiplexed ssh connection is ready
    #
    # Useful for making a single ssh connection that can be reused for many ssh
    # operations.
    #
    # Usage:
    #   SSH="me@example.com"
    #   trap 'ssh -O exit '${SSH} SIGINT SIGTERM EXIT
    #   ssh -N ${SSH} &
    #   _wait_for_ssh ${SSH}
    #   ...use multiplexed ssh connection here...

    local ssh="${1?:ssh hostname required}"

    printf 'Connecting to "%s".\n' "$ssh"
    while ! ssh -q -S "$ControlPath" -O check ${ssh} true 2>/dev/null; do
        printf '.' ; sleep 0.5;
    done
    printf '\nConnected!\n'
}

main() {
    while getopts h opt; do
        case $opt in
        h) awk 'NR == 1 { next } /^$/ { exit } { print substr($0, 3) }' "$0"
           exit ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    local SSH_URI="$1"
    test $# -gt 0 && shift 1

    mkdir -p "$TEMP"
    trap '
        excode=$?; trap - EXIT;
        rm -rf -- '"$TEMP"'
        exit $excode
    ' INT TERM EXIT

    printf 'Looking for Git repos: '

    # Disable output buffering so we can draw a count in real-time.
    stdbuf -i0 -o0 -e0 \
    find -name HEAD -printf '%h\0' | xargs -0 -L1 sh -c \
        'test -O "$1"/refs -a -O "$1"/objects && printf "%s\0" "$1"' - \
        | tee "$REPO_CACHE" \
        | awk '
            BEGIN { RS="\0" }
            { printf("\033[2K\033[1GLooking for Git repos: %s", NR) }
            END { printf("\n") }
        '

    if [ -n "$SSH_URI" ]; then
        ssh -q -M -S "$ControlPath" -N ${SSH_URI} &
        _wait_for_ssh ${SSH_URI}
    fi

    < "$REPO_CACHE" xargs -t -r -0 -P5 -I{} git --git-dir={} fetch --all "$@"

    if [ -n "$SSH_URI" ]; then
        ssh -q -S "$ControlPath" -O exit "$SSH_URI"
    fi

    < "$REPO_CACHE" xargs -0 -n1 \
        | wc -l \
        | xargs printf 'Fetched upstream changes for %s repos.\n'
}

main "$@"
