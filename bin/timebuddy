#!/usr/bin/env sh
# Compare columns of hours in a day across multiple timezones
#
# This provides a quick way to compare times across multiple timezones. For
# example, you need to book a meeting with coworkers in multiple timezones and
# want to know what daylight hours overlap in each.
#
# Example output:
#
# % timebuddy EST America/New_York UTC
# Thu  00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23  Thu - America/Denver
# Thu  02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 00 01  Fri - EST
# Thu  02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 00 01  Fri - America/New_York
# Thu  07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 00 01 02 03 04 05 06  Fri - UTC
#
# Specify a date (accepts any string GNU date will consume):
#
# % timebuddy -d 2022-03-13 UTC America/New_York
#
# Pair with a fuzzy-finder to quickly look up timezone formats.
# E.g.: ftimezone | xargs timebuddy
#
# Format inspired by https://www.worldtimebuddy.com
#
# Requirements: GNU date, /usr/share/zoneinfo

datestr='today'
while getopts xhd: opt; do
    case $opt in
    d) datestr="$OPTARG";;
    h) awk 'NR == 1 { next } /^$/ { exit } { print substr($0, 3) }' "$0"
       exit ;;
    x) set -x;;
    esac
done
shift $(( OPTIND - 1 ))

localtime="$(readlink /etc/localtime)"
curzone="${localtime#*zoneinfo/}"
curoffset="$(TZ="$curzone" date +%z)"

for tgtzone in "$curzone" "$@"; do
    if [ ! -e "/usr/share/zoneinfo/${tgtzone}" ]; then
        printf 'Unknown timezone: %s\n' "$tgtzone" 1>&2
        exit 1
    fi

    printf '%s\n' 00 01 02 03 04 05 06 07 08 09 10 11 12 \
        13 14 15 16 17 18 19 20 21 22 23 \
    | xargs -I{} printf 'TZ="%s" %s {}:00 %s\n' \
        "$curzone" "$datestr" "$curoffset" \
    | TZ="$tgtzone" date "+${tgtzone} %a %H %M" -f -
done | awk '
    function alen(a, i, c) { for (i in a) c += 1; return c; }

    { zone=$1; day=$2; hr=$3; min=$4; uniq_mins[min]=1 }

    {
        if (zone != prev_zone) {
            zone_count += 1
            zone_order[zone_count] = zone
        }

        if (zone_lday[zone] == "") { zone_lday[zone] = day }
        zone_rday[zone] = day
        zone_times[zone] = zone_times[zone] " " hr ":" min

        prev_zone = zone
    }

    END {
        # Some time zones are offset by minutes as well as hours.
        if (alen(uniq_mins) > 1) show_mins=1

        for (i in zone_order) {
            z = zone_order[i]
            if (show_mins != 1) gsub(":[0-9]{2,}", "", zone_times[z])

            printf("%s %s  %s - %s\n",
                zone_lday[z],
                zone_times[z],
                zone_rday[z],
                z)
        }
    }
'
