#!/usr/bin/env sh
# A wrapper to parallelize grep and optionally filter by filename pattern

NAME=$(basename "$0")
VERSION='0.9.0'

help () {
    # Extract contiguous lines of comments in a function as help text

    awk -v cmd="${1:?'Command name required.'}" -v NAME="$NAME" '
    $0 ~ "^" cmd "\\s*\\(\\)\\s*{" { is_found=1; next }
    is_found && !NF { exit }
    is_found { gsub(/^\s*#\s?/, ""); gsub(/NAME/, NAME); print; }
    ' "$0"
}

_main () {
    # A wrapper to parallelize grep and optionally filter by filename pattern
    #
    # ## Usage
    #
    # `NAME [<flags>] searchterm [<searchpath> | (<grep args>...)]`
    #
    #     NAME -h
    #     NAME searchterm
    #     NAME searchterm /search/path
    #     NAME -X '*.js' -X '*.jsx' searchterm
    #     NAME searchterm file1 file2 file3
    #
    # Flag | Description
    # ---- | -----------
    # -V   | Show version.
    # -h   | Usage and help text.
    # -x   | Enable xtrace debug logging.
    # -X   | Filter files by pattern before searching; multiple occurences ok.
    #
    # Flags _must_ be the first argument to `NAME`, before `searchterm`.
    #
    # Search will be case-sensitive if the search text contains capital
    # letters.
    #
    # If given no search path or a single search path this wrapper will use
    # ffind to generate the list of files and parallelize grep using xargs.
    # This list can be additionally filtered by filename pattern using zero or
    # more -X flags.
    #
    # Automatically parallelized:
    # gext searchterm
    # gext searchterm ./searchpath
    # gext -X '*.js' -X '*.jsx' searchterm ./searchpath
    #
    # If given one or more file names to search it will instead behave like
    # regular grep and ffind will not be invoked.
    #
    # Not automatically parallelized (but caller can do that manually):
    # gext searchterm [...files]
    # find . -name '*.foo' -print0 | xargs -0 -P4 gext searchterm

    local opt
    local OPTARG
    local OPTIND

    local ext

    while getopts VhvxX:P: opt; do
        case $opt in
        V) printf 'Version: %s\n' $VERSION
           exit;;
        h) help _main
           printf '\n'
           exit;;
        x) set -x;;
        P)
            if [ -n "$pth" ]; then
                pth="-path ${OPTARG} -o ${pth}"
            else
                pth="-path ${OPTARG}"
            fi
            ;;
        X)
            if [ -n "$ext" ]; then
                ext="-name ${OPTARG} -o ${ext}"
            else
                ext="-name ${OPTARG}"
            fi
            ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    local search="${1:?'Missing "searchterm".'}"; shift

    # Wrap any filename pattern args in parens for find.
    if [ -n "$pth" ]; then
        pth="( ${pth} )"
    fi
    if [ -n "$ext" ]; then
        ext="( ${ext} )"
    fi

    # Check for capital letters in the search pattern.
    if ! $(printf '%s\n' "$search" | grep -q -E '[A-Z]' 2>/dev/null); then
        local is_icase=1
    fi

    # If we're given a search path use find to generate list of files to
    # search, otherwise assume the file list is provided and just pass to grep.
    if [ "$#" -eq 0 ] ; then
        searchpath='.'
    else
        if [ -d "$1" ]; then
            searchpath="$1"
            shift
        fi
    fi

    if [ -n "$searchpath" ]; then
        set -f

        ffind "$searchpath" \
            -type f \
            $ext $pth \
            -print0 \
        | xargs -0 -P8 \
            grep --color \
            ${is_icase:+-i} \
            -nH -E -e "${search}" "$@"
        ret=$?

        set +f
    else
        grep --color \
            ${is_icase:+-i} \
            -nH -E -e "${search}" "$@"
        ret=$?
    fi

    return "$ret"
}

_main "$@"
