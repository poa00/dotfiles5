#!/usr/bin/env sh
# A wrapper to parallelize grep and optionally filter by filename pattern

NAME=$(basename "$0")
TEMP="${TMPDIR-/tmp}/${NAME}.${$}.$(awk \
    'BEGIN {srand(); printf "%d\n", rand() * 10^10}')"
EXIT="${TEMP}/exit"

help () {
    # Extract contiguous lines of comments in a function as help text

    awk -v cmd="${1:?'Command name required.'}" -v NAME="$NAME" '
    $0 ~ "^" cmd "\\s*\\(\\)\\s*{" { is_found=1; next }
    is_found && !NF { exit }
    is_found { gsub(/^\s*#\s?/, ""); gsub(/NAME/, NAME); print; }
    ' "$0"
}

_main () {
    # A wrapper to parallelize grep and optionally filter by filename pattern
    #
    # ## Usage
    #
    # `NAME [<flags>] searchterm [<searchpath> | (<grep args>...)]`
    #
    #     NAME -h
    #     NAME searchterm
    #     NAME searchterm /search/path
    #     NAME -X '*.js' -X '*.jsx' searchterm
    #     NAME searchterm file1 file2 file3
    #
    # Flag | Description
    # ---- | -----------
    # -V   | Show version.
    # -h   | Usage and help text.
    # -x   | Enable xtrace debug logging.
    # -P   | Override parallel xargs processes (defualt: 8).
    # -X   | Filter files by pattern before searching; multiple occurences ok.
    # -T   | Pass additional paths to ffind; multiple occurences ok.
    # -p   | Do not open search results in a pager.
    #
    # Flags _must_ be the first argument to `NAME`, before `searchterm`.
    #
    # Search will be case-sensitive if the search text contains capital
    # letters.
    #
    # If given no search path, a single search path, or specific search paths
    # via `-T` this wrapper will use ffind to generate the list of files and
    # parallelize grep using xargs. This list can be additionally filtered by
    # filename pattern using zero or more -X flags.
    #
    # Automatically parallelized:
    # gext searchterm
    # gext searchterm ./searchpath
    # gext -X '*.js' -X '*.jsx' searchterm ./searchpath
    #
    # If given one or more file names to search it will instead behave like
    # regular grep and ffind will not be invoked.

    local opt
    local OPTARG
    local OPTIND

    local ext

    trap '
        excode=$?; trap - EXIT;
        rm -rf -- '"$TEMP"'
        exit $excode
    ' INT TERM EXIT

    while getopts hxP:pT:X: opt; do
        case $opt in
        h) help _main
           printf '\n'
           exit;;
        x) set -x;;
        P) parallel="$OPTARG" ;;
        p) nopager=1 ;;
        T)
            if [ -n "$pth" ]; then
                pth="-path ${OPTARG} -o ${pth}"
            else
                pth="-path ${OPTARG}"
            fi
            ;;
        X)
            if [ -n "$ext" ]; then
                ext="-name ${OPTARG} -o ${ext}"
            else
                ext="-name ${OPTARG}"
            fi
            ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    local search="${1:?'Missing "searchterm".'}"; shift

    if [ -t 1 ] && [ -z "$nopager" ]; then
        usepager=1;
    fi

    # Wrap any filename pattern args in parens for find.
    if [ -n "$pth" ]; then
        pth="( ${pth} )"
    fi
    if [ -n "$ext" ]; then
        ext="( ${ext} )"
    fi

    # Check for capital letters in the search pattern.
    if ! $(printf '%s\n' "$search" | grep -q -E '[A-Z]' 2>/dev/null); then
        local is_icase=1
    fi

    # If we're given a search path use find to generate list of files to
    # search, otherwise assume the file list is provided and just pass to grep.
    if [ "$#" -eq 0 ] ; then
        searchpath='.'
    else
        if [ -d "$1" ]; then
            searchpath="$1"
            shift
        fi
    fi

    mkdir -p -m 700 "$TEMP"

    {
    if [ -n "$searchpath" ]; then
        set -f

        ffind "$searchpath" \
            -type f \
            $ext $pth \
            -print0 \
        | xargs -0 -P"${parallel:-8}" \
            grep --color"${usepager:+=always}" \
            ${is_icase:+-i} \
            -nH -E -e "${search}" "$@"
        printf '%s\n' $? > "$EXIT"

        set +f
    else
        grep --color"${usepager:+=always}" \
            ${is_icase:+-i} \
            -nH -E -e "${search}" "$@"
        printf '%s\n' $? > "$EXIT"
    fi;
    } | {
        if [ -n "$usepager" ]; then
            $PAGER -FR
        else
            cat
        fi
    }

    # Is there a simpler way to retain the exit code?
    read ret < "$EXIT"
    exit $ret
}

_main "$@"
