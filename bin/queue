#!/usr/bin/env sh
# A lightweight job queue using tail and xargs

NAME=$(basename "$0")
QUEUE_DIR="${PWD}/__queue_jobs"
QUEUE="${QUEUE_DIR}/queue"
MAXJOBS=1

help () {
    # Extract contiguous lines of comments in a function as help text

    awk -v cmd="${1:?'Command name required.'}" -v NAME="$NAME" '
    $0 ~ "^" cmd "\\s*\\(\\)\\s*{" { is_found=1; next }
    is_found && !NF { exit }
    is_found { gsub(/^\s*#\s?/, ""); gsub(/NAME/, NAME); print; }
    ' "$0"
}

_main () {
    # ## Usage
    #
    # `NAME [<flags>] [command to enqueue...]`
    #
    # Flag | Description
    # ---- | -----------
    # -h   | Show this screen.
    # -x   | Enable xtrace debug logging.
    # -n   | Delete the queue file before starting.
    # -P   | Max number of jobs to run in parallel.
    # -L   | List queued jobs and exit.
    # -F   | List failed jobs and exit.
    # -R   | List running jobs and exit.
    #
    # Flags _must_ be the first argument to `NAME`.
    #
    # ### Examples:
    #
    # Start processing the queue, three concurrent jobs at a time:
    #
    #     NAME -P3
    #
    # Add new jobs to the queue:
    #
    #     NAME 'sleep 5 && echo done'
    #     NAME sleep 5 \&\& echo done
    #     NAME echo hi
    #     NAME curl -L -C - 'http://example.com/somedownload.tar.gz' -o myfile.tar.gz

    local opt
    local OPTARG
    local OPTIND

    while getopts hP:nxLFR opt; do
        case $opt in
        h) help _main
           printf '\n'
           exit;;
        P) MAXJOBS="$OPTARG";;
        n) rm -rf "$QUEUE_DIR";;
        L) xargs -0 -n1 < "$QUEUE"; exit ;;
        F) grep -v 'Done 0' "$QUEUE_DIR"/*.ret; exit ;;
        R) find "$QUEUE_DIR" -name '*.ret' -type f -size 0; exit ;;
        x) set -x;;
        esac
    done
    shift $(( OPTIND - 1 ))

    mkdir -p -m 700 "$QUEUE_DIR"
    touch "$QUEUE"

    if [ $# -eq 0 ]; then
        tail -z -n+0 -f "$QUEUE" \
            | xargs -0 -r -I{} -P "$MAXJOBS" sh -c \
                'echo Start $$
                printf '\''%s\n'\'' "{}" > '"$QUEUE_DIR"'/job-$$.job
                touch '"$QUEUE_DIR"'/job-$$.ret
                {} 1>'"$QUEUE_DIR"'/job-$$.out 2>'"$QUEUE_DIR"'/job-$$.err
                echo Done $? | tee '"$QUEUE_DIR"'/job-$$.ret ' \
            | awk '
                BEGIN {
                    OFS="\t\t"
                    running = 0; success = 0; fail = 0
                    print "Queue:", "Running", "Success", "Fail"
                    print "", running, success, fail
                }

                /^Start/ { running += 1 }
                /^Done/ {
                    running -= 1
                    if ($2 == 0) { success += 1 } else { fail += 1 }
                }
                {
                    printf("\033[1A\033[2K") # clear line
                    print "", running, success, fail
                }
            '
    else
        # Try to mimic Bash's printf '%q':
        printf '%s\0' "$*" \
            | sed \
                -e "s/'/'\\\\''/g" \
                -e 's/[|&;<>()$`\\"\*\?\[#~=%\t\n]/\\&/g' \
            >> "$QUEUE"
    fi
}

_main "$@"
