#!/usr/bin/env sh
# (filtering find) - A wrapper around find to ignore noise directories
#
# Usage
#
# `NAME [<flags>] <searchpath> [...other find arguments...]
#
#     NAME -h
#     NAME .
#     NAME ./somepath
#     NAME . -type d
#     NAME . -type f -name '*.js'
#
# Flag | Description
# ---- | -----------
# -V   | Show version.
# -q   | Output filenames in Vim quickfix format.
# -h   | Usage and help text.
# -x   | Enable xtrace debug logging.
#
# Flags _must_ be the first argument to `NAME`, before `searchterm`.
#
# Patterns to ignore are obtained from reading the following files:
#
# - `$HOME/.ffind`
# - `$PWD/.ffind`
# - `$(git rev-parse --show-toplevel)/.ffind`
#
# The ignore file format is one entry per line, with an expression that
# find can consume. Blank lines and comments (#) are ignored:
#
#     # This is a comment.
#
#     -path *.git
#     -path *node_modules
#     -name *.pyc


NAME=$(basename "$0")
VERSION='0.9.0'

_main() {
    while getopts Vqhx opt; do
        case $opt in
        q) quickfix=1;;
        V) printf 'Version: %s\n' $VERSION
           exit;;
        h) awk 'NR == 1 {next} /^$/ {exit} {print substr($0, 3)}' "$0"; exit;;
        x) set -x;;
        esac
    done
    shift $(( OPTIND - 1 ))

    local spath="${1:?'Search path missing.'}"
    shift 1

    if [ -n "$quickfix" ]; then
        set -- "$@" -printf '%p:1: \n'
    fi

    exec 4>&2 2>/dev/null
    local prune="$(cat \
        "${HOME}/.ffind" \
        "${PWD}/.ffind" \
        "$(git rev-parse --show-toplevel)/.ffind" |
        awk '/^-/ { printf("%s%s", sep, $0); sep=" -o " }')"
    exec 2>&4 4>&-

    if [ -n "$prune" ]; then
        prune="( ${prune} ) -prune"
    fi

    case "$@" in
        *-print|*-print0|*-printf*) ;;
        *) local add_print=1 ;;
    esac

    set -f
    find "$spath" \
        $prune \
        -o "$@" \
        ${add_print+-print}
    set +f
}

_main "$@"
